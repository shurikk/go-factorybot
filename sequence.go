package factorybot

import "sync"

// Sequence represents a sequence with a counter
type Sequence struct {
	counter int
	value   func(int) any
	mu      sync.Mutex
}

// One returns next value from the sequence or the value generated by
// the callback function if provided
func (s *Sequence) One() any {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.counter++

	if s.value != nil {
		return s.value(s.counter)
	}

	return s.counter
}

// N increments the counter and returns the value
func (s *Sequence) N() int {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.counter++
	return s.counter
}

// Rewind resets the sequence counter
func (s *Sequence) Rewind() {
	s.counter = 0
}

// NewSequence creates new sequence instance with optional callback function, e.g.
//
//	seq := NewSequence()
//	seq.One() // 1
//	seq.N() // 2
//
// or
//
//	usernames := NewSequence(func(n int) any {
//	    rertun fmt.Sprintf("user-%d", n)
//	})
//
//	usernames.One() // "user-1"
//
// Callback function can return anything, e.g. random values, etc.
func NewSequence(params ...func(n int) any) Sequence {
	if len(params) > 0 {
		return Sequence{value: params[0]}
	}

	return Sequence{}
}
